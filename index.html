<!doctype html>
<html>
<head>
  <title>Data structure vizualizer</title>
  <script src="mori.js"></script>
  <script src="Immutable.min.js"></script>
  <!-- 
    You can find grab include files here:
    http://bentodojo.com/underview/mori.js
    http://bentodojo.com/underview/Immutable.min.js
  -->
  <style type="text/css">
/*    #canvas {
      height: 400px;
      width: 400px;
    }
*/  </style> 
</head>
<body>

  <canvas id="canvas" width="800" height="680"></canvas>
  
  <div style="float:right">
    <p><button id="simple">simple queue</button></p>
    <p><button id="tricky">tricky queue</button></p>

    <p><button id="vector_mori">Mori Vector</button></p>
    
    <p><button id="queue_mori">Mori Queue</button></p>
    <p><button id="map_mori">Mori Map random</button></p>

    <p><button id="vector_fb">FB Vector queue</button></p>
    <p><button id="map_fb_r">FB Map random</button></p>
    <p><button id="map_fb_s">FB Map sequential</button></p>
    
    <hr />
    
    <p><button id="stop">Stop!</button></p>    
    <p><button id="toggle_black">Toggle black</button></p>

    <p>Sat: <input type="range" id="sat_value" value="10" max="50"></p>
    <p>Lit: <input type="range" id="lit_value" value="40" max="60"></p>
    <p>Spd: <input type="range" id="spd_value" value="30" max="200"></p>
    
    <p><button id="poke_simple">Poke simple</button></p>
  </div>

  <script>
    var el = document.getElementById.bind(document)
    var ctx = el('canvas').getContext('2d')
        
    // canvas manipulation functions
    
    function shift(context, dx) {
      dx = dx || -1
      
      var w = context.canvas.width
      var h = context.canvas.height
      var imageData = context.getImageData(0, 0, w, h);
      
      ctx.clearRect(0, 0, w, h);
      context.putImageData(imageData, dx, 0);
      
      return false
    }
    
    function draw_cols(context, data, offset) {
      data = data || ds
      
      var w = context.canvas.width
      var h = context.canvas.height
      
      // var list = flatten(data)
      data.forEach(function(item, index) {        
        var c = "hsl(" + item + ", 60%, 60%)"
        if(item == -1)
          c = "hsl(0, 0%, 0%)"
        context.fillStyle = c
        context.fillRect(w-1-offset, index, 1, 1);
      })
      
      return false
    }
    
    function fancy_draw_cols(context, data, offset) {
      data = data || ds
      
      var w = context.canvas.width
      var h = context.canvas.height
      
      // var list = flatten(data)
      data.forEach(function(item, index) {
        var hue = item[0] ?    item[0]     : item
        var sat = item[1] ? ''+item[1]+'%' : '60%'
        var lit = item[2] ? ''+item[2]+'%' : '60%'
        
        var c = 'hsl(' + hue + ', ' + sat + ', ' + lit + ')'
        
        if(item == -1)
          c = 'hsl(0, 0%, 0%)'
          
        context.fillStyle = c
        context.fillRect(w-1-offset, index, 1, 1);
      })
      
      return false
    }
    
    // prep funs for pipeline
    
    var shiftctx = partial(shift, ctx)
    var drawctx = partial(fancy_draw_cols, ctx)
    
    function shifter(data) {
      shiftctx(-1 * (data||[]).length)
      return data
    }
    
    function drawer(data, context) {
      var len = data.length
      data.forEach(function(arr, ind) {drawctx(arr, len-ind)})
      return data
    }
    
    
    ///// a data structure thing ok
    
    ds = []
    
    var init = function() {for(i=0; i<100; i++) { ds.push(rand()) }}
    
    init()
    
    ////// 
        
    // Object.observe(ds, function(changes){
    //   changes.forEach(function(change) {
    //     console.log(change.type, change.name, change.oldValue);
    //   });
    // });
    
    // Array.observe(ds, function(changeRecords) {
    //   console.log('Array observe', changeRecords);
    // });
    
    /*
    
    ok. hi! today you're going to do this stuff:
    - observe the array and change the pixels based on it [copy + shift?]
    - flatten deeper trees (multiple ways)
    - color by value, diff, change, locality, etc
    - open omnigraffle to start fiddling with structure diagrams
    - build a simple animation thingy
    - slides & more slides on paper or something
    - notebook + paper + computer consolidation [where?]
    
    
    step -> (draw + shift)
    - draw takes an array of color data (either just h or hsl)
    
    render -> doctor_data -> step
    
    what I really want is a thing with some stuff that does things.
    
    
    */
    
    
    
    build_renderer = function(pipeline) {
      var queued_render = false
      var queued_data = []
      
      function renderer() {
        queued_render = false
        
        pipeline.reduce(function(data, fun) {
          return fun(data)
        }, queued_data)
        
        queued_data = []
      }
      
      return function(data) {
        queued_data.push(data) 
        if(queued_render) return false

        queued_render = true
        window.requestAnimationFrame(renderer)
        // setTimeout(renderer, 100)
      }
    }


    //////
    
    function flatten(data) {
      if(!data && data !== 0)
        return NaN
      
      if(typeof data == 'object') 
        data = flatten_object(data)

      if(Array.isArray(data))
        return flatten_array(data)
      
      if(typeof data != 'number')
        return NaN
        
      return data
    }
    
    function flatten_array(arr) {
      return ['down'].concat(arr.reduce(function(acc, item) {return acc.concat(flatten(item))}, []).filter(NoNaN), 'up')
      // return arr.map(flatten).filter(NoNaN)
    }
    
    function flatten_object(obj) {
      return ['down'].concat(Object.keys(obj).reduce(function(acc, key) {return acc.concat(obj[key])}, []), 'up')
    }
    
    function NoNaN(x) {
      return x === x // o ___ o
    }
    
    var stupidGlobalSatConstant = 10
    var stupidGlobalLitConstant = 40
    var stupidGlobalSpdConstant = 30
    
    var stupidGlobalHueFun = function(item, level) { return item }
    var stupidGlobalSatFun = function(item, level) { return Math.max(100+level*stupidGlobalSatConstant, 0) }
    var stupidGlobalLitFun = function(item, level) { return Math.max(100+level*stupidGlobalLitConstant, 0) }
    
    var stupidGlobalBlackLines = false
    
    function valuation(list) {
      return list.map(function(data) {
        var level = 0
        return data.reduce(function(acc, item) {
          if(+item == item) {
            var hue = stupidGlobalHueFun(item, level)
            var sat = stupidGlobalSatFun(item, level)
            var lit = stupidGlobalLitFun(item, level)
            acc.push([hue, sat, lit]) // oh no not like that!
            return acc
          }
          
          if(item == 'down') level--
          if(item == 'up')   level++
          if(stupidGlobalBlackLines)
            acc.push([1, 1, 1]) // oh no not like that!
          return acc
        }, [])
      })
    }
    
    function colorize(data) {
      return data
    }
    
    
    /// make it go. or stop. whatever.
    
    going = false /// what are you serious? nononono. eradicate this.
    
    function stop() {going = false}

    var goer = function(fun) {
      going = true; 
      function really_go() {
        fun() 
        if(going) {
          if(+stupidGlobalSpdConstant)
            setTimeout(really_go, +stupidGlobalSpdConstant)
          else
            setImmediate(really_go)
        }
      }
      really_go()
      // ~(function really_go() {fun(step()); if(going) {setImmediate(really_go)}})()
    }
    
    var makego = function(stepper) {
      var gobase = function(stepfun) { renderer( stepfun() ) }
      return partial(goer, partial(gobase, stepper))
    }

    function flatten_each(data) {return data.map(flatten)}

    var pipeline = [flatten_each, valuation, colorize, shifter, drawer]
    var renderer = build_renderer(pipeline)
    
    
    // steppers and goers

    function simple_step() { ds.push(rand()); ds.shift(); return ds.slice() }
        
    
    function tricky_step() { 
      if(rand(1.5)) {
        ds.push(rand()); 
        ds.shift();         
      }
      else if(rand(1.1)) {
        ds[25] = 0
        ds[26] = 0
        ds[27] = 0
      } 
      else if(rand(1.5)) {
        ds[75] = 200
        ds[76] = 200
      }
      return ds.slice()
    }
    
    
    /// mori vector
    // redo this!
    
    var vector_mori = mori.mutable.thaw(mori.vector())
    
    function vector_mori_step() {
      vector_mori = mori.mutable.conj1(vector_mori, rand())
      if(mori.count(vector_mori) > 350)
        vector_mori = mori.mutable.pop(vector_mori)
      return vector_mori
    }
    
    /// mori queue

    var queue_mori = mori.queue()
    
    function queue_mori_step() {
      queue_mori = mori.conj(queue_mori, rand())
      if(mori.count(queue_mori) > 200)
        queue_mori = mori.pop(queue_mori)
      return queue_mori
    }
    
    /// mori map

    var map_mori = mori.hash_map()
    
    function map_mori_step() {
      var n = rand(350)
      map_mori = mori.assoc(map_mori, 'a'+n, n)
      return map_mori
    }
    
    
    /// fb vector
    
    var vect = Immutable.Vector()
    
    function vector_step() {
      vect = vect.push(rand()) // TODO: do this sans global
      if(vect.length > 360)
        vect = vect.shift()
      return vect
    }
    
    
    /// fb map random
    
    var map_fb_r = Immutable.Map()
    
    function map_fb_r_step() {
      var n = rand(350)
      map_fb_r = map_fb_r.set('a'+n, n) // TODO: do this sans global
      return map_fb_r
    }
    
    /// fb map sequential
    
    var map_fb_s = Immutable.Map()
    
    function map_fb_s_step() {
      var n = rand(350)
      map_fb_s = map_fb_s.set('a'+n, n) // TODO: do this sans global
      return map_fb_s
    }
    
    
    // go fun

    var go_simple = makego(simple_step)
    var go_tricky = makego(tricky_step)

    var go_vector_mori = makego(vector_mori_step)
    var go_queue_mori = makego(queue_mori_step)
    var go_map_mori = makego(map_mori_step)

    var go_vector = makego(vector_step)
    var go_map_fb_r = makego(map_fb_r_step)
    var go_map_fb_s = makego(map_fb_s_step)
    
    
    // try sequentially instead of adding randomly to the map
    // binary tree -- change saturation so you can see unbalanced tree easily
    // diff coloring so you can see hotspots
    
    
    // dom bindings
    
    function clickit(elstr, fun) { el(elstr).addEventListener('click', function() { fun() }) }
    clickit('simple', go_simple)
    clickit('tricky', go_tricky)

    clickit('vector_mori', go_vector_mori)
    clickit('queue_mori', go_queue_mori)
    clickit('map_mori', go_map_mori)

    clickit('vector_fb', go_vector)
    clickit('map_fb_r', go_map_fb_r)
    clickit('map_fb_s', go_map_fb_s)

    clickit('stop', stop)
    clickit('toggle_black', function() { stupidGlobalBlackLines = !stupidGlobalBlackLines })

    el('sat_value').addEventListener('change', function(elem) { 
      stupidGlobalSatConstant = elem.target.value
    })
    el('lit_value').addEventListener('change', function(elem) { 
      stupidGlobalLitConstant = elem.target.value
    })
    el('spd_value').addEventListener('change', function(elem) { 
      stupidGlobalSpdConstant = elem.target.value
    })
    
    clickit('poke_simple', function() {
      for (var i = 0; i < 9; i++) {
        ds[5+i*10] = 300
      }
    }) 
    
    
    
    // helpers
    
    function rand(n) { return Math.floor(Math.random() * (n||256)) }
    
    function partial(fun) {
      var args = [].slice.call(arguments, 1)
      return function() {
        var new_args = [].slice.call(arguments)
        return fun.apply(fun, args.concat(new_args))
      }
    }
    
    ~function() {
        //// postpone until next tick
        // inspired by http://dbaron.org/log/20100309-faster-timeouts
        var later = []
        var messageName = 12345
        var gimme_a_tick = true

        function setImmediate(fun) {
            later.push(fun)
        
            if(gimme_a_tick) {
                gimme_a_tick = false
                window.postMessage(messageName, "*")
            }
        
            return false
        }

        function handleMessage(event) {
            if(event.data != messageName) return false

            event.stopPropagation()
            gimme_a_tick = true

            var now = later
            later = []

            for(var i=0, l=now.length; i < l; i++)
                now[i]()
        }
  
        if(typeof window != 'undefined') {
            window.addEventListener('message', handleMessage, true)
            window.setImmediate = setImmediate
        }
    }()
    
    
    
    /*
      dead code
    
      function draw_color(context, color) {
        context = context || ctx
        color = color || Math.floor( Math.random() * 360 )
      
        var w = context.canvas.width
        var h = context.canvas.height
        var c = "hsl(" + color + ", 60%, 60%)"
      
        ctx.fillStyle = c
        ctx.fillRect(w-1, 0, 1, h);
      }
        
    
    */
        
  </script>
  
</body>  
</html>