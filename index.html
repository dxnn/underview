<!doctype html>
<html>
<head>
  <title>Data structure vizualizer</title>
  <script src="Immutable.min.js"></script>
  <style type="text/css">
/*    #canvas {
      height: 400px;
      width: 400px;
    }
*/  </style> 
</head>
<body>

  <canvas id="canvas" width="800" height="650"></canvas>
  
  <button id="pushme">Push me</button>

  <script>
    var el = document.getElementById.bind(document)
    var ctx = el('canvas').getContext('2d')
    
    // canvas manipulation functions
    
    function shift(context, dx) {
      dx = dx || -1
      
      var w = context.canvas.width
      var h = context.canvas.height
      var imageData = context.getImageData(0, 0, w, h);
      
      // ctx.clearRect(0, 0, w, h);
      context.putImageData(imageData, dx, 0);
      
      return false
    }
    
    function draw_cols(context, data, offset) {
      data = data || ds
      
      var w = context.canvas.width
      var h = context.canvas.height
      
      // var list = flatten(data)
      data.forEach(function(item, index) {        
        var c = "hsl(" + item + ", 60%, 60%)"
        if(item == -1)
          c = "hsl(0, 0%, 0%)"
        context.fillStyle = c
        context.fillRect(w-1-offset, index, 1, 1);
      })
      
      return false
    }
    
    function fancy_draw_cols(context, data, offset) {
      data = data || ds
      
      var w = context.canvas.width
      var h = context.canvas.height
      
      // var list = flatten(data)
      data.forEach(function(item, index) {
        var hue = item[0] ?    item[0]     : item
        var sat = item[1] ? ''+item[1]+'%' : '60%'
        var lit = item[2] ? ''+item[2]+'%' : '60%'
        
        var c = 'hsl(' + hue + ', ' + sat + ', ' + lit + ')'
        
        if(item == -1)
          c = 'hsl(0, 0%, 0%)'
          
        context.fillStyle = c
        context.fillRect(w-1-offset, index, 1, 1);
      })
      
      return false
    }
    
    // prep funs for pipeline
    
    var shiftctx = partial(shift, ctx)
    var drawctx = partial(fancy_draw_cols, ctx)
    
    function shifter(data) {
      shiftctx(-1 * (data||[]).length)
      return data
    }
    
    function drawer(data, context) {
      var len = data.length
      data.forEach(function(arr, ind) {drawctx(arr, len-ind)})
      return data
    }
    
    
    ///// a data structure thing ok
    
    ds = []
    
    var init = function() {for(i=0; i<100; i++) { ds.push(rand()) }}
    
    init()
    
    ////// 
        
    // Object.observe(ds, function(changes){
    //   changes.forEach(function(change) {
    //     console.log(change.type, change.name, change.oldValue);
    //   });
    // });
    
    // Array.observe(ds, function(changeRecords) {
    //   console.log('Array observe', changeRecords);
    // });
    
    /*
    
    ok. hi! today you're going to do this stuff:
    - observe the array and change the pixels based on it [copy + shift?]
    - flatten deeper trees (multiple ways)
    - color by value, diff, change, locality, etc
    - open omnigraffle to start fiddling with structure diagrams
    - build a simple animation thingy
    - slides & more slides on paper or something
    - notebook + paper + computer consolidation [where?]
    
    
    step -> (draw + shift)
    - draw takes an array of color data (either just h or hsl)
    
    render -> doctor_data -> step
    
    what I really want is a thing with some stuff that does things.
    
    
    */
    
    
    
    build_renderer = function(pipeline) {
      var queued_render = false
      var queued_data = []
      
      function renderer() {
        queued_render = false
        
        pipeline.reduce(function(data, fun) {
          return fun(data)
        }, queued_data)
        
        queued_data = []
      }
      
      return function(data) {
        queued_data.push(data) 
        if(queued_render) return false

        queued_render = true
        window.requestAnimationFrame(renderer)
        // setTimeout(renderer, 100)
      }
    }


    //////
    
    function flatten(data) {
      if(!data && data !== 0)
        return NaN
      
      if(typeof data == 'object') 
        data = flatten_object(data)

      if(Array.isArray(data))
        return flatten_array(data)
      
      if(typeof data != 'number')
        return NaN
        
      return data
    }
    
    function flatten_array(arr) {
      return ['down'].concat(arr.reduce(function(acc, item) {return acc.concat(flatten(item))}, []).filter(NoNaN), 'up')
      // return arr.map(flatten).filter(NoNaN)
    }
    
    function flatten_object(obj) {
      return ['down'].concat(Object.keys(obj).reduce(function(acc, key) {return acc.concat(obj[key])}, []), 'up')
    }
    
    function NoNaN(x) {
      return x === x // o ___ o
    }
    
    function valuation(list) {
      return list.map(function(data) {
        var level = 0
        return data.reduce(function(acc, item) {
          if(+item == item) {
            var sat = Math.max(100+level*10, 0)
            acc.push([item, sat, sat]) // TODO: make this optional
            return acc
          }
          
          if(item == 'down') level--
          if(item == 'up')   level++
          acc.push([1, 1, 1]) // TODO: make this optional
          return acc
        }, [])
      })
    }
    
    function colorize(data) {
      return data
    }
    
    
    /// make it go. or stop. whatever.
    
    going = false /// what are you serious? nononono. eradicate this.
    
    function stop() {going = false}

    var goer = function(fun) {
      going = true; 
      ~(function really_go() {fun(); if(going) {setTimeout(really_go, 30)}})()
      // ~(function really_go() {fun(step()); if(going) {setImmediate(really_go)}})()
    }
    
    var makego = function(stepper) {
      var gobase = function(stepfun) { renderer( stepfun() ) }
      return partial(goer, partial(gobase, stepper))
    }

    function flatten_each(data) {return data.map(flatten)}

    var pipeline = [flatten_each, valuation, colorize, shifter, drawer]
    var renderer = build_renderer(pipeline)
    
    
    // steppers and goers

    function simple_step() { ds.push(rand()); ds.shift(); return ds.slice() }
    
    var go_simple = makego(simple_step)
    
    
    function tricky_step() { 
      if(rand(1.5)) {
        ds.push(rand()); 
        ds.shift();         
      }
      else if(rand(1.1)) {
        ds[25] = 0
        ds[26] = 0
        ds[27] = 0
      } 
      else if(rand(1.5)) {
        ds[75] = 200
        ds[76] = 200
      }
      return ds.slice()
    }
    
    var go_tricky = makego(tricky_step)
    
    /// fb vector
    
    var vect = Immutable.Vector()
    
    for (var i = 0; i < 500; i++) {
      vect = vect.push(rand())
    }
    
    function vector_step() {
      vect = vect.push(rand()).shift() // TODO: do this sans global
      return vect
    }
    
    var go_vector = makego(vector_step)
    
    /// fb map
    
    var map = Immutable.Map()
    
    function map_step() {
      var n = rand(350)
      map = map.set('a'+n, n) // TODO: do this sans global
      return map
    }
    
    var go_map = makego(map_step)
    
    
    // try sequentially
    // binary tree -- change saturation so you can see unbalanced tree easily
    // diff coloring so you can see hotspots
    
    
    
    
    // var realfun = map_step
    // var realfun = vector_step
    // var go = partial(go_1, partial(gobase, realfun))
    
    // var go = function(fun) {
    //   fun = fun || renderer
    //   going = true;
    //   ~(function really_go() {renderer(step()); if(going) {setTimeout(really_go, 30)}})()}
    
    
    // helpers
    
    function rand(n) { return Math.floor(Math.random() * (n||256)) }
    
    function partial(fun) {
      var args = [].slice.call(arguments, 1)
      return function() {
        var new_args = [].slice.call(arguments)
        return fun.apply(fun, args.concat(new_args))
      }
    }
    
    ~function() {
        //// postpone until next tick
        // inspired by http://dbaron.org/log/20100309-faster-timeouts
        var later = []
        var messageName = 12345
        var gimme_a_tick = true

        function setImmediate(fun) {
            later.push(fun)
        
            if(gimme_a_tick) {
                gimme_a_tick = false
                window.postMessage(messageName, "*")
            }
        
            return false
        }

        function handleMessage(event) {
            if(event.data != messageName) return false

            event.stopPropagation()
            gimme_a_tick = true

            var now = later
            later = []

            for(var i=0, l=now.length; i < l; i++)
                now[i]()
        }
  
        if(typeof window != 'undefined') {
            window.addEventListener('message', handleMessage, true)
            window.setImmediate = setImmediate
        }
    }()
    
    
    
    /*
      dead code
    
      function draw_color(context, color) {
        context = context || ctx
        color = color || Math.floor( Math.random() * 360 )
      
        var w = context.canvas.width
        var h = context.canvas.height
        var c = "hsl(" + color + ", 60%, 60%)"
      
        ctx.fillStyle = c
        ctx.fillRect(w-1, 0, 1, h);
      }
        
    
    */
    
    el('pushme').addEventListener('click', function() {
      for (var i = 0; i < 9; i++) {
        ds[5+i*10] = 300
      }
    })
    
  </script>
  
</body>  
</html>